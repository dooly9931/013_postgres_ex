use std::collections::{HashMap, VecDeque};

use chrono::{Duration, NaiveDateTime, Utc};
use rust_decimal::Decimal;
use tokio_postgres::{Client, NoTls};

use crate::target::{Target, TargetUpdate, Timestamp};

pub struct DbClient {
    client: Client,
}

impl DbClient {
    pub async fn new(uri: &str) -> Self {
        let (client, connection) = match tokio_postgres::connect(uri, NoTls).await {
            Ok((cl, co)) => (cl, co),
            Err(error) => panic!("{}", error),
        };
        let handle = tokio::spawn(async move {
            if let Err(error) = connection.await {
                panic!("{}", error);
            }
        });
        let db_exists = match client.query("SELECT datname FROM pg_database", &[]).await {
            Ok(rows) => rows
                .iter()
                .map(|row| row.get::<&str, &str>("datname"))
                .any(|db_name| db_name == "casanova"),
            Err(error) => panic!("{}", error),
        };
        if !db_exists {
            match client.execute("CREATE DATABASE casanova", &[]).await {
                Ok(_res) => println!("database 'casanova' is created"),
                Err(error) => panic!("{}", error),
            }
        } else {
            println!("database 'casanova' exists");
        }
        handle.abort();
        let (client, connection) =
            match tokio_postgres::connect(format!("{}/casanova", uri).as_str(), NoTls).await {
                Ok((cl, co)) => (cl, co),
                Err(error) => panic!("{}", error),
            };
        tokio::spawn(async move {
            if let Err(error) = connection.await {
                panic!("{}", error);
            }
        });
        let (current_exists, update_exists) = match client
            .query(
                "SELECT tablename FROM pg_catalog.pg_tables WHERE schemaname = 'public'",
                &[],
            )
            .await
        {
            Ok(rows) => {
                let mut table_names = rows.iter().map(|row| row.get::<&str, &str>("tablename"));
                (
                    table_names.any(|table_name| table_name == "current"),
                    table_names.any(|table_name| table_name == "update"),
                )
            }
            Err(error) => panic!("{}", error),
        };
        if !current_exists {
            match client
                .execute(
                    "CREATE TABLE IF NOT EXISTS current (
            id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            datetime timestamp(6) NOT NULL,
            symbol varchar(8) NOT NULL,
            amount varchar(32) NOT NULL
        )",
                    &[],
                )
                .await
            {
                Ok(_res) => println!("table 'current' is created"),
                Err(error) => panic!("{}", error),
            }
        } else {
            println!("table 'current' exists");
        }
        if !update_exists {
            match client
                .execute(
                    "CREATE TABLE IF NOT EXISTS update (
            id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            datetime timestamp(6) NOT NULL,
            symbol varchar(8) NOT NULL,
            amount varchar(32) NOT NULL
        )",
                    &[],
                )
                .await
            {
                Ok(_res) => println!("table 'update' is created"),
                Err(error) => panic!("{}", error),
            }
        } else {
            println!("table 'update' exists");
        }
        Self { client }
    }

    pub async fn create_database(&mut self, db_name: &str) {
        match self
            .client
            .execute(format!("CREATE DATABASE {}", db_name).as_str(), &[])
            .await
        {
            Ok(res) => {
                println!("\n{}", res);
            }
            Err(error) => {
                println!("{}", error);
            }
        }
    }

    pub async fn show_database(&mut self) {
        match self
            .client
            .query("SELECT datname FROM pg_database", &[])
            .await
        {
            Ok(rows) => rows.iter().for_each(|row| {
                println!("{} ", row.get::<&str, &str>("datname"));
            }),
            Err(error) => {
                println!("show: {}", error);
            }
        }
    }

    pub async fn drop_database(&mut self) {
        match self
            .client
            .execute("DROP DATABASE IF EXISTS casanova", &[])
            .await
        {
            Ok(_res) => println!("database 'casanova' dropped"),
            Err(error) => panic!("{}", error),
        }
    }

    pub async fn create_current_table(&mut self) {
        match self
            .client
            .execute(
                "CREATE TABLE IF NOT EXISTS current (
                id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
                datetime timestamp(6) with time zone NOT NULL,
                symbol varchar(8) NOT NULL,
                amount varchar(32)
            )",
                &[],
            )
            .await
        {
            Ok(res) => {
                println!("\n{}", res);
            }
            Err(error) => {
                println!("{}", error);
            }
        }
    }

    pub async fn show_tables(&mut self) {
        match self
            .client
            .query(
                "SELECT * from pg_catalog.pg_tables
            WHERE schemaname != 'pg_catalog' AND schemaname != 'information_schema'",
                &[],
            )
            .await
        {
            Ok(rows) => rows.iter().for_each(|row| {
                println!();
                for i in 0..row.len() {
                    match row.try_get::<usize, &str>(i) {
                        Ok(value) => {
                            print!("{} ", value);
                        }
                        Err(error) => {
                            print!("{} ", error);
                        }
                    }
                }
            }),
            Err(error) => {
                println!("{}", error);
            }
        }
    }

    pub async fn show_table_schema(&mut self, table_name: &str) {
        match self.client.query("SELECT table_name, column_name, data_type FROM information_schema.columns WHERE table_name = $1", &[&table_name]).await {
            Ok(rows) => rows.iter().for_each(|row| {
                for i in 0..row.len() {
                    match row.try_get::<usize, &str>(i) {
                        Ok(value) => {
                            print!("{} ", value);
                        }
                        Err(error) => {
                            print!("{} ", error);
                        }
                    }
                }
                println!();
            }),
            Err(error) => {
                print!("{} ", error);
            }
        }
    }

    pub async fn insert_current(&mut self, symbol: &str, amount: &str) {
        let datetime = Utc::now().naive_utc();
        match self
            .client
            .execute(
                "INSERT INTO current (datetime, symbol, amount) VALUES ($1, $2, $3)",
                &[&datetime, &symbol, &amount],
            )
            .await
        {
            Ok(_res) => (),
            Err(error) => panic!("{}", error),
        }
    }

    pub async fn select_all_current(&mut self) {
        match self.client.query("SELECT * FROM current", &[]).await {
            Ok(rows) => {
                rows.iter()
                    .map(|row| {
                        (
                            row.get::<&str, NaiveDateTime>("datetime"),
                            row.get::<&str, &str>("symbol"),
                            Decimal::from_str_exact(row.get::<&str, &str>("amount")).unwrap(),
                        )
                    })
                    .for_each(|tup| println!("{:?}", tup));
            }
            Err(error) => panic!("{}", error),
        }
    }

    pub async fn select_latest_current(&mut self) {
        match self
            .client
            .query(
                "SELECT * FROM current WHERE datetime = (SELECT MAX(datetime) FROM current)",
                &[],
            )
            .await
        {
            Ok(rows) => {
                rows.iter()
                    .map(|row| {
                        (
                            row.get::<&str, NaiveDateTime>("datetime"),
                            row.get::<&str, &str>("symbol"),
                            Decimal::from_str_exact(row.get::<&str, &str>("amount")).unwrap(),
                        )
                    })
                    .for_each(|tup| println!("{:?}", tup));
            }
            Err(error) => panic!("{}", error),
        }
    }

    pub async fn insert_update(&mut self, timestamp: Timestamp, symbol: &str, amount: &str) {
        let datetime = NaiveDateTime::from_timestamp_micros(timestamp.try_into().unwrap()).unwrap();
        match self
            .client
            .execute(
                "INSERT INTO update (datetime, symbol, amount) VALUES ($1, $2, $3)",
                &[&datetime, &symbol, &amount],
            )
            .await
        {
            Ok(_res) => (),
            Err(error) => panic!("{}", error),
        }
    }

    pub async fn select_all_update(&mut self) {
        match self.client.query("SELECT * FROM update", &[]).await {
            Ok(rows) => {
                rows.iter()
                    .map(|row| {
                        (
                            row.get::<&str, NaiveDateTime>("datetime"),
                            row.get::<&str, &str>("symbol"),
                            Decimal::from_str_exact(row.get::<&str, &str>("amount")).unwrap(),
                        )
                    })
                    .for_each(|tup| println!("{:?}", tup));
            }
            Err(error) => panic!("{}", error),
        }
    }

    pub async fn read_target(&mut self) -> Target {
        let current: HashMap<String, Decimal> = match self
            .client
            .query(
                "SELECT * FROM current WHERE datetime = (SELECT MAX(datetime) FROM current)",
                &[],
            )
            .await
        {
            Ok(rows) => HashMap::from_iter(rows.iter().map(|row| {
                (
                    row.get::<&str, String>("symbol"),
                    Decimal::from_str_exact(row.get::<&str, &str>("amount")).unwrap(),
                )
            })),
            Err(error) => panic!("{}", error),
        };
        let update_from = (Utc::now() - Duration::days(30)).naive_utc();
        let mut updates: VecDeque<TargetUpdate> = VecDeque::new();
        match self
            .client
            .query(
                "SELECT * FROM update WHERE datetime > $1 ORDER BY datetime",
                &[&update_from],
            )
            .await
        {
            Ok(rows) => rows.iter().for_each(|row| {
                let timestamp: u64 = row
                    .get::<&str, NaiveDateTime>("datetime")
                    .timestamp_micros()
                    .try_into()
                    .unwrap();
                let symbol = row.get::<&str, String>("symbol");
                let amount = Decimal::from_str_exact(row.get::<&str, &str>("amount")).unwrap();
                if updates.is_empty() || updates.back().unwrap().timestamp != timestamp {
                    let new = TargetUpdate {
                        timestamp,
                        amount_diff: HashMap::from([(symbol, amount)]),
                    };
                    updates.push_back(new);
                } else {
                    let mut back = updates.pop_back().unwrap();
                    *back.amount_diff.entry(symbol).or_default() = amount;
                    updates.push_back(back);
                }
            }),
            Err(error) => panic!("{}", error),
        }
        Target::new(current, updates)
    }
}
